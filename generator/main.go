// This program converts a single PNG image into a C++ header file.
// The output format is optimized for ESP32 microcontrollers, storing the image
// data in flash memory (PROGMEM) to conserve RAM.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"image"
	"image/color"
	"image/draw"
	_ "image/png" // Import the PNG decoder
	"log/slog"
	"math"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/lmittmann/tint"
)

// colorDef is used for sorting colors to ensure a deterministic output order.
type colorDef struct {
	Color color.RGBA
	Name  string
}

// Point defines a 2D coordinate.
type Point struct {
	X int `json:"x"`
	Y int `json:"y"`
}

// ColorData holds the hex value and all coordinates for a single color.
type ColorData struct {
	ColorHex string
	Points   []Point
	VarName  string // Variable name for the points array
}

// ImageData holds all the processed data for a single image file.
type ImageData struct {
	VarName      string // e.g., "image_logo"
	FriendlyName string // e.g., "logo"
	ColorSets    []ColorData
}

// TemplateData is the top-level struct passed to the Go template for a single image.
type TemplateData struct {
	GuardName string
	Image     ImageData
}

// This is the Go template that will generate the C++ header file.
// It's structured to create PROGMEM-compatible C-style arrays for a single image.
const headerTemplate = `// Generated by image_converter.go for {{.Image.FriendlyName}}
#ifndef {{.GuardName}}_H
#define {{.GuardName}}_H

#include <Arduino.h>

// Struct to hold a single pixel coordinate
struct ColorPoint {
    uint8_t x;
    uint8_t y;
};

// Struct to hold data for a single color, pointing to its points in PROGMEM
struct ColorData {
    uint32_t color;
    uint16_t point_count;
    const ColorPoint* points;
};

// Struct for a single image, pointing to its color data in PROGMEM
struct ImageData {
    const char* name;
    uint8_t color_count;
    const ColorData* data;
};

{{$img := .Image}}
// --- Image Data for: {{$img.FriendlyName}} ---
{{range .Image.ColorSets}}
{{$cs := .}}
const ColorPoint {{.VarName}}[] PROGMEM = {
    {{- range $i, $p := $cs.Points}}
    { {{$p.X}}, {{$p.Y}} }{{if ne $i (sub (len $cs.Points) 1)}}, {{end}}
    {{- end}}
};
{{end}}
const ColorData data_{{$img.FriendlyName}}[] PROGMEM = {
    {{- range $i, $cs := $img.ColorSets}}
    { 0x{{$cs.ColorHex}}, {{len $cs.Points}}, {{$cs.VarName}} }{{if ne $i (sub (len $img.ColorSets) 1)}},{{end}}
    {{- end}}
};
const char name_{{$img.FriendlyName}}[] PROGMEM = "{{$img.FriendlyName}}";

// The final, single image data structure for this file.
const ImageData IMAGE_DATA PROGMEM = { name_{{$img.FriendlyName}}, {{len $img.ColorSets}}, data_{{$img.FriendlyName}} };

#endif // {{.GuardName}}_H
`

func main() {
	// --- Logger Setup ---
	slog.SetDefault(slog.New(
		tint.NewHandler(os.Stderr, &tint.Options{Level: slog.LevelDebug, TimeFormat: time.Kitchen}),
	))

	// --- Command Line Flags (Updated for single file input) ---
	fileIn := flag.String("in", "", "Input PNG image file.")
	fileOut := flag.String("out", "", "Output header file name. Defaults to <input_filename>.h")
	tolerance := flag.Float64("tolerance", 10.0, "Color similarity tolerance (0-100). Higher values group more colors.")
	flag.Parse()

	if *fileIn == "" {
		slog.Error("âŒ Input image file is required. Use the -in flag.", "flag", "-in")
		os.Exit(1)
	}

	// Default output file name logic
	if *fileOut == "" {
		baseName := filepath.Base(*fileIn)
		ext := filepath.Ext(baseName)
		*fileOut = fmt.Sprintf("%s.h", strings.TrimSuffix(baseName, ext))
	}

	slog.Info("ðŸš€ Let's get creative! Starting image conversion...", "input_file", *fileIn, "output_file", *fileOut, "tolerance", *tolerance)

	// --- Process the single file ---
	imageData, err := processFile(*fileIn, *tolerance)
	if err != nil {
		slog.Error("âŒ Oh no! Failed to process the image.", "path", *fileIn, "error", err)
		os.Exit(1)
	}

	// --- Generate Header File from Template ---
	slog.Info("âœ¨ Abracadabra! Generating the C++ header file...")

	// Create a valid C++ identifier for the include guard
	guardName := strings.ToUpper(strings.ReplaceAll(filepath.Base(*fileOut), ".", "_"))
	templateData := TemplateData{
		GuardName: guardName,
		Image:     *imageData,
	}

	// Template functions for simple math
	funcMap := template.FuncMap{
		"sub": func(a, b int) int {
			return a - b
		},
	}

	tmpl, err := template.New("header").Funcs(funcMap).Parse(headerTemplate)
	if err != nil {
		slog.Error("âŒ Template trouble! Couldn't parse the Go template.", "error", err)
		os.Exit(1)
	}

	var outputBuffer bytes.Buffer
	if err := tmpl.Execute(&outputBuffer, templateData); err != nil {
		slog.Error("âŒ Template execution failed! The magic spell fizzled.", "error", err)
		os.Exit(1)
	}

	// --- Write to File ---
	if err := os.WriteFile(*fileOut, outputBuffer.Bytes(), 0644); err != nil {
		slog.Error("âŒ File write failed! Couldn't save the masterpiece.", "path", *fileOut, "error", err)
		os.Exit(1)
	}

	slog.Info("ðŸŽ‰ All done! Your C++ header is ready to shine.", "output_written", *fileOut)
}

// processFile handles the conversion of a single image file.
func processFile(filePath string, tolerance float64) (*ImageData, error) {
	slog.Debug("âš™ï¸ Working my magic on", "path", filePath)

	file, err := os.Open(filePath)
	if err != nil {
		return nil, fmt.Errorf("could not open file: %w", err)
	}
	defer file.Close()

	img, _, err := image.Decode(file)
	if err != nil {
		return nil, fmt.Errorf("could not decode image: %w", err)
	}

	slog.Debug("âœ… Decoded successfully", "width", img.Bounds().Dx(), "height", img.Bounds().Dy())

	finalImage := processImage(img, tolerance)
	slog.Debug("âœ… Image resized and processed")

	colorSets, err := convertToColorData(finalImage, tolerance)
	if err != nil {
		return nil, fmt.Errorf("could not convert to custom format: %w", err)
	}

	friendlyName := strings.TrimSuffix(filepath.Base(filePath), filepath.Ext(filePath))
	// Sanitize name to be a valid C++ variable name
	sanitizedName := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') {
			return r
		}
		return '_'
	}, friendlyName)

	imageData := &ImageData{
		VarName:      "image_" + sanitizedName,
		FriendlyName: sanitizedName,
		ColorSets:    colorSets,
	}

	// Assign variable names for each color's point array
	for i := range imageData.ColorSets {
		imageData.ColorSets[i].VarName = fmt.Sprintf("points_%s_c%d", sanitizedName, i)
	}

	return imageData, nil
}

// processImage resizes, centers, and applies color substitutions.
func processImage(img image.Image, tolerance float64) *image.RGBA {
	// targetWidth, targetHeight := 64, 160 // TODO
	targetWidth, targetHeight := 64, 192

	// Calculate new dimensions while preserving aspect ratio (Thumbnail logic)
	srcBounds := img.Bounds()
	srcWidth := float64(srcBounds.Dx())
	srcHeight := float64(srcBounds.Dy())
	ratio := math.Min(float64(targetWidth)/srcWidth, float64(targetHeight)/srcHeight)
	newWidth := int(srcWidth * ratio)
	newHeight := int(srcHeight * ratio)

	resizedImg := resizeNearestNeighbor(img, newWidth, newHeight)
	slog.Debug("âœ… Resized and centered", "new_width", newWidth, "new_height", newHeight)

	canvas := image.NewRGBA(image.Rect(0, 0, targetWidth, targetHeight))
	offsetX := (targetWidth - newWidth) / 2
	offsetY := (targetHeight - newHeight) / 2
	drawRect := image.Rect(offsetX, offsetY, offsetX+newWidth, offsetY+newHeight)
	draw.Draw(canvas, drawRect, resizedImg, image.Point{0, 0}, draw.Over)

	black := color.RGBA{R: 0, G: 0, B: 0, A: 255}
	darkBlue := color.RGBA{R: 2, G: 29, B: 84, A: 255}
	bounds := canvas.Bounds()
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			originalColor := canvas.RGBAAt(x, y)
			if colorDistance(originalColor, black) <= tolerance && originalColor.A > 0 {
				canvas.Set(x, y, color.RGBA{R: darkBlue.R, G: darkBlue.G, B: darkBlue.B, A: originalColor.A})
			}
		}
	}
	return canvas
}

// resizeNearestNeighbor scales an image to a new width and height using the nearest neighbor algorithm.
func resizeNearestNeighbor(src image.Image, newWidth, newHeight int) image.Image {
	dst := image.NewRGBA(image.Rect(0, 0, newWidth, newHeight))
	srcBounds := src.Bounds()
	srcW := srcBounds.Dx()
	srcH := srcBounds.Dy()
	xRatio := float64(srcW) / float64(newWidth)
	yRatio := float64(srcH) / float64(newHeight)

	for y := 0; y < newHeight; y++ {
		for x := 0; x < newWidth; x++ {
			srcX := int(math.Floor(float64(x) * xRatio))
			srcY := int(math.Floor(float64(y) * yRatio))
			pixel := src.At(srcBounds.Min.X+srcX, srcBounds.Min.Y+srcY)
			dst.Set(x, y, pixel)
		}
	}
	return dst
}

// convertToColorData groups pixels by color and returns the structured data.
func convertToColorData(img *image.RGBA, tolerance float64) ([]ColorData, error) {
	colorMap := make(map[color.RGBA][]Point)
	bounds := img.Bounds()

	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			c := img.RGBAAt(x, y)
			if c.A == 0 {
				continue // Skip transparent pixels
			}

			var foundMatch bool
			for k := range colorMap {
				if colorDistance(c, k) <= tolerance {
					colorMap[k] = append(colorMap[k], Point{X: x, Y: y})
					foundMatch = true
					break
				}
			}
			if !foundMatch {
				colorMap[c] = []Point{{X: x, Y: y}}
			}
		}
	}
	slog.Debug("ðŸŽ¨ Grouping similar colors", "unique_colors", len(colorMap))

	var colorDefs []colorDef
	for c := range colorMap {
		colorDefs = append(colorDefs, colorDef{Color: c, Name: fmt.Sprintf("%02X%02X%02X", c.R, c.G, c.B)})
	}
	sort.Slice(colorDefs, func(i, j int) bool {
		return colorDefs[i].Name < colorDefs[j].Name
	})

	var result []ColorData
	for _, def := range colorDefs {
		points := colorMap[def.Color]
		result = append(result, ColorData{
			ColorHex: def.Name,
			Points:   points,
		})
	}
	return result, nil
}

// colorDistance calculates the perceptual distance between two colors using the "red-mean" formula.
func colorDistance(c1, c2 color.RGBA) float64 {
	rMean := (float64(c1.R) + float64(c2.R)) / 2.0
	dR := float64(c1.R) - float64(c2.R)
	dG := float64(c1.G) - float64(c2.G)
	dB := float64(c1.B) - float64(c2.B)
	return math.Sqrt((2+rMean/256.0)*dR*dR + 4*dG*dG + (2+(255.0-rMean)/256.0)*dB*dB)
}
